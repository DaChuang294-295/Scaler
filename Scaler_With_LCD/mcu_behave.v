/*
* This is a file generated by ARM Cortex-M3 wizard.
* Please do not edit this file!
* Generated time: 11/20/2013 16:13:02
* Version: Primace 6.0 Alpha
* Wizard name: ARM Cortex-M3 1.0a
*
*/
// ============================================================
// File Name: armcm3_v1_core.v
// IP core : armcm3
// Device name: M7A-TAPEOUT
// ============================================================
`define HSINGLE   3'b000 //Single burst
`define HINCR     3'b001 //Incrementing burst of undefined lengt
`define HWRAP4    3'b010 //4-beat wrapping burst
`define HINCR4    3'b011 //4-beat incrementing burst
`define HWRAP8    3'b100 //8-beat wrapping burst
`define HINCR8    3'b101 //8-beat incrementing burst
`define HWRAP16   3'b110 //16-beat wrapping burst
`define HINCR16   3'b111 //16-beat incrementing burst

`define HIDLE     2'b00
`define HBUSY     2'b01
`define HNSEQ     2'b10
`define HSEQ      2'b11

`define H8        3'b000
`define H16       3'b001
`define H32       3'b010

module M7S_SOC(
    fp2soc_rst_n,
    c2r1_dll_clk,
    fp_lvds_sclk,
	fp_clk_sys,
    fp_clk_adc,
    fp_clk_arm,
    fp_clk_usb,
    clk_eth_tx,
    fp_clk_ddrc,
	// peripherals
    gpio_0_out_o,
    gpio_0_oe_o,
    gpio_0_in_i,
    i2c0_scl_oe_o,
    i2c0_sda_oe_o,
    i2c0_scl_i,
    i2c0_sda_i,
    i2c1_scl_oe_o,
    i2c1_sda_oe_o,
    i2c1_scl_i,
    i2c1_sda_i,
    uart0_rts_o,
    uart0_txd_o,
    uart0_cts_i,
    uart0_rxd_i,
    uart1_rts_o,
    uart1_txd_o,
    uart1_cts_i,
    uart1_rxd_i,
    spi0_mosi,
    spi0_sck,
    spi0_ssn,
    spi0_miso,
    spi1_mosi,
    spi1_sck,
    spi1_ssn,
    spi1_miso,
    pad_can0_o_clk,
    pad_can0_o_tx1,
    pad_can0_o_tx0,
    pad_can0_oen_tx1,
    pad_can0_oen_tx0,
    pad_can0_i_rx0,
    pad_can1_o_clk,
    pad_can1_o_tx1,
    pad_can1_o_tx0,
    pad_can1_oen_tx1,
    pad_can1_oen_tx0,
    pad_can1_i_rx0,
	// for fp1
    clk_ahb_fp1,
    rst_ahb_fp1_n,
    fp1_m_ahb_mastlock,
    fp1_m_ahb_prot,
    fp1_m_ahb_size,
    fp1_m_ahb_addr,
    fp1_m_ahb_write,
    fp1_m_ahb_burst,
    fp1_m_ahb_trans,
    fp1_m_ahb_wdata,
    fp1_m_ahb_ready,
    fp1_m_ahb_resp,
    fp1_m_ahb_rdata,
    fp1_s_ahb_mastlock,
    fp1_s_ahb_prot,
    fp1_s_ahb_size,
    fp1_s_ahb_sel,
    fp1_s_ahb_addr,
    fp1_s_ahb_write,
    fp1_s_ahb_burst,
    fp1_s_ahb_trans,
    fp1_s_ahb_wdata,
    fp1_s_ahb_readyout,
    fp1_s_ahb_resp,
    fp1_s_ahb_rdata,
	//for fp0
	clk_ahb_fp0,
    rst_ahb_fp0_n,
    fp0_m_ahb_mastlock,
    fp0_m_ahb_prot,
    fp0_m_ahb_size,
    fp0_m_ahb_addr,
    fp0_m_ahb_write,
    fp0_m_ahb_burst,
    fp0_m_ahb_trans,
    fp0_m_ahb_wdata,
    fp0_m_ahb_ready,
    fp0_m_ahb_resp,
    fp0_m_ahb_rdata,
    fp0_s_ahb_mastlock,
    fp0_s_ahb_prot,
    fp0_s_ahb_size,
    fp0_s_ahb_sel,
    fp0_s_ahb_addr,
    fp0_s_ahb_write,
    fp0_s_ahb_burst,
    fp0_s_ahb_trans,
    fp0_s_ahb_wdata,
    fp0_s_ahb_readyout,
    fp0_s_ahb_resp,
    fp0_s_ahb_rdata,
	//int 
    fp_INTNMI
);

parameter SIM_FIFO = 0;

parameter use_arm = 1'b1;
parameter use_clk_arm = 1'b1;
parameter use_pbus0 =1'b1;
parameter use_pbus1 =1'b1;
parameter use_on_chip_eth =1'b0;
parameter use_on_chip_usb =1'b0;
parameter use_on_chip_ddr_ctrl =1'b0;
parameter use_on_chip_adc =12'b000000000000;
parameter use_uart_io =1'b0;
parameter use_arm_nmi =1'b0;
parameter program_file ="";
  

input           fp2soc_rst_n;
input           c2r1_dll_clk;
input           fp_lvds_sclk;
input           fp_clk_sys;
input           fp_clk_adc;
input           fp_clk_arm;
input           fp_clk_usb;
input           clk_eth_tx;
input           fp_clk_ddrc;
input           i2c0_scl_i;
input           i2c0_sda_i;
input [31:0]    gpio_0_in_i;
input           i2c1_scl_i;
input           i2c1_sda_i;
input           uart0_cts_i;
input           uart0_rxd_i;
input           uart1_cts_i;
input           uart1_rxd_i;
input           spi0_miso;
input           spi1_miso;
input           pad_can0_i_rx0;
input           pad_can1_i_rx0;

output [31:0]   gpio_0_out_o;
output [31:0]   gpio_0_oe_o;
output          i2c0_scl_oe_o;
output          i2c0_sda_oe_o;
output          i2c1_scl_oe_o;
output          i2c1_sda_oe_o;
output          uart0_rts_o;
output          uart0_txd_o;
output          uart1_rts_o;
output          uart1_txd_o;
output          spi0_mosi;
output          spi0_sck;
output          spi0_ssn;
output          spi1_mosi;
output          spi1_sck;
output          spi1_ssn;
output          pad_can0_o_clk;
output          pad_can0_o_tx1;
output          pad_can0_o_tx0;
output          pad_can0_oen_tx1;
output          pad_can0_oen_tx0;
output          pad_can1_o_clk;
output          pad_can1_o_tx1;
output          pad_can1_o_tx0;
output          pad_can1_oen_tx1;
output          pad_can1_oen_tx0;

// for fp1
input           clk_ahb_fp1;
input           rst_ahb_fp1_n;
input           fp1_m_ahb_mastlock;
input  [3: 0]   fp1_m_ahb_prot;
input  [2: 0]   fp1_m_ahb_size;
input  [31:0]   fp1_m_ahb_addr;
input           fp1_m_ahb_write;
input  [2: 0]   fp1_m_ahb_burst;
input  [1: 0]   fp1_m_ahb_trans;
input  [31:0]   fp1_m_ahb_wdata;
output          fp1_m_ahb_ready;
output          fp1_m_ahb_resp;
output [31:0]   fp1_m_ahb_rdata;
output          fp1_s_ahb_mastlock;
output [3: 0]   fp1_s_ahb_prot;
output [2: 0]   fp1_s_ahb_size;
output          fp1_s_ahb_sel;
output [31:0]   fp1_s_ahb_addr;
output          fp1_s_ahb_write;
output [2: 0]   fp1_s_ahb_burst;
output [1: 0]   fp1_s_ahb_trans;
output [31:0]   fp1_s_ahb_wdata;
input           fp1_s_ahb_readyout;
input           fp1_s_ahb_resp;
input  [31:0]   fp1_s_ahb_rdata;
input  [15:0]   fp_INTNMI;

//for fp0
input           clk_ahb_fp0;
input           rst_ahb_fp0_n;
input           fp0_m_ahb_mastlock;
input  [3 :0]   fp0_m_ahb_prot;
input  [2 :0]   fp0_m_ahb_size;
input  [31:0]   fp0_m_ahb_addr;
input           fp0_m_ahb_write;
input  [2: 0]   fp0_m_ahb_burst;
input  [1: 0]   fp0_m_ahb_trans;
input  [31:0]   fp0_m_ahb_wdata;
output          fp0_m_ahb_ready;
output          fp0_m_ahb_resp;
output [31:0]   fp0_m_ahb_rdata;
output          fp0_s_ahb_mastlock;
output [3: 0]   fp0_s_ahb_prot;
output [2: 0]   fp0_s_ahb_size;
output          fp0_s_ahb_sel;
output [31:0]   fp0_s_ahb_addr;
output          fp0_s_ahb_write;
output [2: 0]   fp0_s_ahb_burst;
output [1: 0]   fp0_s_ahb_trans;
output [31:0]   fp0_s_ahb_wdata;
input           fp0_s_ahb_readyout;
input           fp0_s_ahb_resp;
input [31:0]    fp0_s_ahb_rdata;

//********************************************* //
//--------assign the output ports unused -------//
assign          gpio_0_out_o = {32'hxxxxxxxx};
assign          gpio_0_oe_o = 32'hxxxxxxxx;
assign          i2c0_scl_oe_o = 1'bx;
assign          i2c0_sda_oe_o = 1'bx;
assign          i2c1_scl_oe_o = 1'bx;
assign          i2c1_sda_oe_o = 1'bx;
assign          uart0_rts_o = 1'bx;
assign          uart0_txd_o = 1'bx;
assign          uart1_rts_o = 1'bx;
assign          uart1_txd_o = 1'bx;
assign          spi0_mosi = 1'bx;
assign          spi0_sck = 1'bx;
assign          spi0_ssn = 1'bx;
assign          spi1_mosi = 1'bx;
assign          spi1_sck = 1'bx;
assign          spi1_ssn = 1'bx;
assign          pad_can0_o_clk = 1'bx;
assign          pad_can0_o_tx1 = 1'bx;
assign          pad_can0_o_tx0 = 1'bx;
assign          pad_can0_oen_tx1 = 1'bx;
assign          pad_can0_oen_tx0 = 1'bx;
assign          pad_can1_o_clk = 1'bx;
assign          pad_can1_o_tx1 = 1'bx;
assign          pad_can1_o_tx0 = 1'bx;
assign          pad_can1_oen_tx1 = 1'bx;
assign          pad_can1_oen_tx0= 1'bx;

//**************************************//

//-----------------MCU Behave Begin----------------
wire         fp0_m_ahb_ready;
reg [31:0]   fp0_m_ahb_rdata;

reg [31:0] SRAM_MEM [0:1024*8];
reg [31:0] DDRMEM [0:1024*768];
integer i,j;
initial begin
    for(i=0; i<768; i++) begin
        for(j=0; j<1024; j++) begin
            if(j<128)
                DDRMEM[i*1024 + j] = 32'h0000_0000;
            else if(j<2*128)
                DDRMEM[i*1024 + j] = 32'h00ff_0000;
            else if(j<3*128)
                DDRMEM[i*1024 + j] = 32'h0000_ff00;
            else if(j<4*128)
                DDRMEM[i*1024 + j] = 32'h00ff_ff00;
            else if(j<5*128)
                DDRMEM[i*1024 + j] = 32'h0000_00ff;
            else if(j<6*128)
                DDRMEM[i*1024 + j] = 32'h00ff_00ff;
            else if(j<7*128)
                DDRMEM[i*1024 + j] = 32'h0000_ffff;
            else
                DDRMEM[i*1024 + j] = 32'h00ff_ffff;
        end
    end
    for(i=0; i<1; i++) begin
        for(j=0; j<1024; j++) begin
            if(j<512)
                SRAM_MEM[i*1024 + j] = 32'h00ff_0000;
            else
                SRAM_MEM[i*1024 + j] = 32'h0000_ff00;
        end
    end
    for(i=1; i<8; i++) begin
        for(j=0; j<1024; j++) begin
            SRAM_MEM[i*1024 + j] = 32'h0000_0000;
        end
    end
end

assign fp0_m_ahb_resp = 1'b0; //OKAY respone
assign fp0_m_ahb_ready = 1'b1;

always@(posedge clk_ahb_fp0, negedge rst_ahb_fp0_n) begin
    if(!rst_ahb_fp0_n)
        fp0_m_ahb_rdata <= 0;
    else if(!fp0_m_ahb_write && (fp0_m_ahb_trans == `HNSEQ || fp0_m_ahb_trans == `HSEQ) && (fp0_m_ahb_size == `H32) && (fp0_m_ahb_burst == `HINCR16)) begin
        if((fp0_m_ahb_addr >= 32'h6000_0000) && (fp0_m_ahb_addr <= 32'h9fff_ffff))
            fp0_m_ahb_rdata <= DDRMEM[fp0_m_ahb_addr[31:2]-{28'h6000_000,2'h0}];
        if((fp0_m_ahb_addr >= 32'h2000_4000) && (fp0_m_ahb_addr <= 32'h2000_bfff))
            fp0_m_ahb_rdata <= SRAM_MEM[fp0_m_ahb_addr[31:2]-{28'h2000_400,2'h0}];
    end
    else if(fp0_m_ahb_trans == `HIDLE)
        fp0_m_ahb_rdata <= 0;
end

//-----------------MCU Behave End----------------

endmodule

